{"version":3,"sources":["algorithms/easyBFS.js","algorithms/mediumBFS.js","algorithms/hardBFS.js","algorithms/hamilton.js","components/Display.js","App.js","serviceWorker.js","index.js"],"names":["BOARD_SIZE","easyBFS","snake","target","nodeBoard","cellVal","headCoordinate","head","value","Math","floor","rowId","colId","visited","Array","pow","fill","queue","path","push","temp","tail","revSnake","unshift","next","diff","i","length","preventReverse","currentNode","shift","tempNode","previousNodePath","isPath","node","potentialNeighbor","neighbors","row","col","findNeighbors","forEach","neighbor","mediumBFS","snakeCells","has","findHeadRC","hardBFS","encounteredSnakeCells","newSnakeCells","Set","pathBreakthroughToTarget","breakThroughCell","snakeCopy","Object","create","returnPair","endTarget","counter","includes","findCellClosestTail","encCellClosestTail","distFromTail","delete","pathToTail","concat","pathToEncountered","exit","dfsPath","dfs","cell","currentLength","locPath","pop","toTar","add","NUMBER_VERTICES","hamiltonSolverDFS","graph","pos","included","v","isSafe","hamilton","hamiltonGraph","nodeAdjacency","valueRow","valueCol","setHamiltonAdjacencyList","map","val","STARTING_POS","LinkedList","LinkedListNode","this","Node","Display","useState","algorithm","setAlgorithm","board","currRow","createBoard","cellHover","setCellHover","setExit","hamiltonRoute","setHamiltonRoute","rowIdx","cellIdx","setNodeBoard","route","setRoute","running","setRunning","showInfo","setShowInfo","showSnakeWin","setShowSnakeWin","showUserWin","setShowUserWin","setSnake","setSnakeCells","setTarget","cursor","useEffect","moveSnake","hamiltonSnakeToTarget","toggleHover","playerWin","handleShowUserWin","setTargetNodeInBoard","isTarget","from","pathToAppend","splice","indexOf","nextSnakeHeadVal","undefined","newHead","currentHead","size","handleShowSnakeWin","setTimeout","handleReset","handleCloseInfo","handleShowInfo","handleGameEndPopupClose","handleGameEndPopupCloseAndReset","id","onClick","icon","faInfoCircle","Modal","show","onHide","Header","closeButton","Title","Body","style","color","Footer","Button","variant","Dropdown","as","ButtonGroup","Toggle","split","Menu","Item","className","onMouseEnter","onMouseLeave","setNextTarget","centered","textAlign","margin","App","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b5ea98d8.chunk.js","sourcesContent":["const BOARD_SIZE = 12\n\n// Main running function for easyBFS - basic BFS implementation\nfunction easyBFS (snake, target, nodeBoard){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = []\n    queue.push(nodeBoard[rowId][colId])\n\n    preventReverse(snake, visited)\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(currentNode, nodeBoard)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value]){\n                visited[neighbor.value] = true\n                nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                queue.push(neighbor)\n            }\n        })\n    }\n    return path\n}\n\n// Helper function to prevent the snake from moving backward when\n// food is placed \"behind\" the head.\nfunction preventReverse(snake, visited){\n    let temp = snake.tail\n    let revSnake = []\n\n    while(temp){\n        revSnake.unshift(temp.value)\n        temp = temp.next\n    }\n    let diff = revSnake[1] - revSnake[0]\n    visited[revSnake[0]] = true\n    visited[revSnake[1]] = true\n    for(let i=1; i<revSnake.length-1; i++){\n        if(revSnake[i+1] - revSnake[i] === diff) visited[revSnake[i+1]]=true\n        else break\n    }\n}\n\n// Finds the neighbors of a cell for BFS\nfunction findNeighbors(node, nodeBoard){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n// Find the row and column of a given cell, so its place can be determined\n// in the nodeBoard\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\n\nexport default easyBFS","const BOARD_SIZE = 12\n\n// Main running function for mediumBFS - BFS implementation\n// Only looks at cells popped out of the queue that are not already\n//  visited AND not a part of the current snake\nfunction mediumBFS (snake, target, nodeBoard, snakeCells){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = []\n    queue.push(nodeBoard[rowId][colId])\n\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(currentNode, nodeBoard)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value] && !snakeCells.has(neighbor.value)){\n                visited[neighbor.value] = true\n                nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                queue.push(neighbor)\n            }\n        })\n    }\n    return path\n}\n\n// Finds neighbors of a cell for BFS\nfunction findNeighbors(node, nodeBoard){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n// Find the row and column of a given cell, so its place can be determined\n// in the nodeBoard\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\nexport default mediumBFS"," /*\n    *  If there is no direct path to the target, hardBFS will look at \n    *  all of the snakeCells that it encounters, and will go to that encountered\n    *  cell which is closest to the tail of the snake. I will call this cell X.\n    * \n    *  If X is the tail of the snake, the head of the snake will follow the tail through\n    *  the \"wall\", until it can reach the target.\n    * \n    *  If X is not the tail: \n    *    If the distance along the BFS path from the head of the snake to X is less \n    *    than the distance from X to the tail of the snake along the snake, then after \n    *    however many moves it takes the head of the snake to get to X, the tail of \n    *    the snake will have moved on and the path will be clear.\n    * \n    *    If that distance is greater, the snake will find a path with a length at least 1 \n    *    greater than the distance from X to the tail of the snake. If no path found, player wins.\n    */\n\nimport mediumBFS from '../algorithms/mediumBFS'\n\nconst BOARD_SIZE = 12\n\n// Main running function for hardBFS\n// Much more case handling if no direct path is found\nfunction hardBFS (snake, target, nodeBoard, snakeCells){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = [], encounteredSnakeCells = []\n    queue.push(nodeBoard[rowId][colId])\n\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(currentNode, nodeBoard)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value]){\n                if(!snakeCells.has(neighbor.value)){\n                    visited[neighbor.value] = true\n                    nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                    queue.push(neighbor)\n                }\n                else encounteredSnakeCells.push(neighbor.value)\n            }\n        })\n    }\n    if(path.length===0) {\n        // Find the cell closest to the tail with a direct path to target\n        let newSnakeCells = new Set(snakeCells)\n        let temp = snake.tail\n        let pathBreakthroughToTarget = [], breakThroughCell = -1\n        while(!pathBreakthroughToTarget.length && temp.next){\n            breakThroughCell = temp.value\n            let snakeCopy = Object.create(snake)\n            snakeCopy.head = Object.create(temp)\n            snakeCopy.head.value = breakThroughCell\n\n            pathBreakthroughToTarget = mediumBFS(snakeCopy, target, nodeBoard, snakeCells)\n            temp = temp.next\n        }\n        let returnPair = findCellClosestTail(snake, encounteredSnakeCells)\n        let encCellClosestTail = returnPair[0], distFromTail = returnPair[1]\n\n        // If head can reach the tail, head will follow tail until it can reach target\n        if(encCellClosestTail===snake.tail.value){\n            newSnakeCells.delete(encCellClosestTail)\n            let pathToTail = mediumBFS(snake, encCellClosestTail, nodeBoard, newSnakeCells)\n            let temp = snake.tail.next\n            while(temp.next && newSnakeCells.has(breakThroughCell)){\n                pathToTail.push(temp.value)\n                newSnakeCells.delete(temp.value)\n                temp = temp.next\n            }\n            return pathToTail.concat(pathBreakthroughToTarget)\n        }\n        // If head must wait for the tail to pass (cannot follow)\n        else{\n            newSnakeCells.delete(encCellClosestTail)\n            let pathToEncountered = mediumBFS(snake, encCellClosestTail, nodeBoard, newSnakeCells)\n            // If the tail will be clear after y moves it takes the head to arrive, path to target is clear\n            if(distFromTail+1<pathToEncountered.length){\n                let temp = snake.tail\n                while(temp.next && newSnakeCells.has(temp.value)){\n                    newSnakeCells.delete(temp.value)\n                    temp = temp.next\n                }\n                let snakeCopy = Object.create(snake)\n                snakeCopy.head = Object.create(temp)\n                snakeCopy.head.value = encCellClosestTail\n                return pathToEncountered.concat(mediumBFS(snakeCopy, target, nodeBoard, newSnakeCells))\n            }\n            // Otherwise head must \"wait\" by moving along a longer path until the tail will be clear after y\n            // moves it takes the head to arrive\n            else{\n                let exit = 0\n                let dfsPath = []\n                //DFS function to find path with length at least 1 more than dist from breakthrough to tail\n                var dfs = function(cell, currentLength, locPath){\n                    if(currentLength>=distFromTail+1 && cell.value===encCellClosestTail){\n                        exit = 1\n                        return locPath\n                    }\n                    if(currentLength>distFromTail+4) return\n                    let currentNeighbors = findNeighbors(cell, nodeBoard)\n                    currentNeighbors.forEach(neighbor => {\n                        if(exit===0 && !locPath.includes(neighbor.value) && !newSnakeCells.has(neighbor.value)){\n                            locPath.push(neighbor.value)\n                            dfs(neighbor, currentLength+1, locPath)\n                            if(exit===0) locPath.pop()\n                        }\n                    })\n                }\n                let headCoordinate = findHeadRC(snake.head.value)\n                let rowId = headCoordinate[0], colId = headCoordinate[1]\n                dfs(nodeBoard[rowId][colId], 0, dfsPath)\n                let toTar = []\n                if(dfsPath.length){\n                    let temp = snake.tail\n                    newSnakeCells.add(encCellClosestTail)\n                    while(temp.next && newSnakeCells.has(encCellClosestTail)){\n                        newSnakeCells.delete(temp.value)\n                        temp = temp.next\n                    }\n                    let snakeCopy = Object.create(snake)\n                    snakeCopy.head = Object.create(temp)\n                    snakeCopy.head.value = encCellClosestTail\n                    toTar = mediumBFS(snakeCopy, target, nodeBoard, newSnakeCells)\n                }\n                return dfsPath.concat(toTar)\n            }\n        }\n    }\n    return path\n}\n\n\n// Helper function that finds the cell in encounteredCells which is\n// closest to the tail of the snake. \nfunction findCellClosestTail(snake, encounteredSnakeCells){\n    let temp = snake.tail\n    let endTarget = -1\n    let counter = 0\n    while(temp.next){\n        if(encounteredSnakeCells.includes(temp.value)){\n            endTarget = temp.value\n            break\n        }\n        temp = temp.next\n        counter++\n    }\n    return [endTarget, counter]\n}\n\n// Finds the neighbors of a cell for BFS\nfunction findNeighbors(node, nodeBoard){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n// Find the row and column of a given cell, so its place can be determined\n// in the nodeBoard\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\nexport default hardBFS","/*\n * Finds the Hamilton Path using DFS and backtracking, which is usually a O(n!)\n * operation. It would not work for grid larger than 6x6, when\n * I set the adjacency list so each node points to every neighbor node. \n * \n * I then set out to implement it with Dynamic Programming and Bitmasking, \n *  as can be seen in the function HAMILTONSOLVERDP. This algorithm is much faster,\n *  but I am not very competant with Bitwise operations, so I could only use \n *  this algorithm to find if a path existed, but could not get the \n *  function to return the path.\n * \n *  So I returned to the DFS and backtracking solution, but made some \n *  changes to my adjacency list. Since the Hamilton Path will follow \n *  the same pattern for even side-length grids, I changed each node to only \n *  be adjacent to the nodes which follow this Hamilton pattern,\n *  although there are other valid Hamilton patterns / paths. This forced DFS to explore\n *  far fewer permutations, and therefore run significantly faster.\n * \n * Algorithms sourced from:\n * DFS/Backtracking: https://www.geeksforgeeks.org/hamiltonian-cycle-backtracking-6/\n * DP: https://www.geeksforgeeks.org/hamiltonian-path-using-dynamic-programming/\n*/\n\nconst BOARD_SIZE = 12\nconst NUMBER_VERTICES = Math.pow(BOARD_SIZE, 2)\n\nfunction hamilton (){\n    let hamiltonGraph = setHamiltonAdjacencyList()\n    let path = new Array(BOARD_SIZE).fill(-1)\n    path[0] = 0\n    let included = new Set()\n    included.add(0)\n    if(hamiltonSolverDFS(hamiltonGraph, path, 1, included)===false) return []\n    path = path.map(val => val+1)\n    return path\n}\n\nfunction hamiltonSolverDFS(graph, path, pos, included){\n    if(pos===NUMBER_VERTICES){\n        if(graph[path[pos-1]][path[0]]===1) return true\n        else return false\n    }\n    for(let v=1; v<NUMBER_VERTICES; v++){\n        if(isSafe(v, graph, path, pos, included)){\n            path[pos] = v\n            included.add(v)\n            if(hamiltonSolverDFS(graph, path, pos+1, included)===true) return true\n            path[pos] = -1\n            included.delete(v)\n        }\n    }\n    return false\n}\n\nfunction isSafe(v, graph, path, pos, included){\n    if(graph[path[pos-1]][v]===0) return false\n    if(included.has(v)) return false\n    return true\n}\n\nfunction setHamiltonAdjacencyList(){\n    let hamiltonGraph = []\n    for(let i=0; i<NUMBER_VERTICES; i++){\n        let nodeAdjacency = new Array(NUMBER_VERTICES).fill(0)\n        let valueRow = Math.floor(i/BOARD_SIZE)\n        let valueCol = i%BOARD_SIZE\n\n        if(valueRow===0){\n            if(valueCol===0){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1\n            }\n        }\n        else if(valueRow===BOARD_SIZE-1){\n            if(valueCol===0){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1\n            }\n        }\n        else{\n            if(valueCol===0){\n                nodeAdjacency[i+BOARD_SIZE] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else if(valueCol===1){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1            \n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1          \n            }\n        }\n        hamiltonGraph.push(nodeAdjacency)\n    }\n    return hamiltonGraph\n}\n\n// function hamiltonSolverDP(graph, path){\n//     let N = graph.length\n\n//     let dp = new Array(N).fill(new Array(1 << N))\n//     for(let i=0; i<N; i++){\n//         dp[i][1<<i] = true\n//     }\n\n//     for(let i=0; i < (1<<N); i++){\n//         for(let j=0; j<N; j++){\n//             if((i & (1<<j)) !== 0){\n//                 for(let k=0; k<N; k++){\n//                     if((i & (1<<k)) !== 0 && \n//                         graph[k][j]===1 && j!==k &&\n//                         dp[k][i ^ (1<<j)]){\n//                             console.log(graph[k][j])\n//                             dp[j][i] = true\n//                             break\n//                         }\n//                 }\n//             }\n//         }\n//     }\n//     for(let i=0; i<N; i++){\n//         if(dp[i][(1<<N)-1]) return true\n//     }\n//     return false\n// }\n\n    \nexport default hamilton","/*\n  Resources: \n  https://gsurma.medium.com/slitherin-solving-the-classic-game-of-snake-with-ai-part-1-domain-specific-solvers-d1f5a5ccd635\n\n  EASY: BFS with basic self detection\n    - Prevents snake from going backward on itself\n    - If trapped (no currnent path to target) snake takes shortest path to end game\n\n  MEDIUM: BFS with improved self detection \n    - Easy + \n    - Snake finds shortest path around its current self\n    - Snake will not run into itself unless trapped (no path) by its body\n\n  Hard: Continual BFS with optimized self detection \n    - Easy + Medium + \n    - If snake traps itself, find longest path to target and move 1\n      then run medium BFS again, until it is no longer trapped or cannot move\n\n  Impossible: Hamiltonian Cycle (Snake visits every node exactly once)\n*/\nimport React, { useState, useEffect } from 'react'\nimport Button from 'react-bootstrap/Button'\nimport ButtonGroup from 'react-bootstrap/ButtonGroup'\nimport Dropdown from 'react-bootstrap/Dropdown'\nimport Modal from 'react-bootstrap/Modal'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faInfoCircle } from '@fortawesome/free-solid-svg-icons'\n\nimport easyBFS from '../algorithms/easyBFS'\nimport mediumBFS from '../algorithms/mediumBFS'\nimport hardBFS from '../algorithms/hardBFS'\nimport hamilton from '../algorithms/hamilton'\n\nimport './css/display.css'\nimport 'bootstrap/dist/css/bootstrap.min.css'\n\nconst BOARD_SIZE = 12\nconst SNAKE_SPEED = 75\nconst STARTING_POS = 75\n\nconst Display = () => {\n  const[algorithm, setAlgorithm] = useState(\"\")\n  const[board] = useState(createBoard(BOARD_SIZE))\n  const[cellHover, setCellHover] = useState(-1)\n  const[exit, setExit] = useState(0)\n  const[hamiltonRoute, setHamiltonRoute] = useState([])\n  const[nodeBoard, setNodeBoard] = useState(\n    board.map((row, rowIdx) => (\n      row.map((cellVal, cellIdx) => (\n        new Node(cellVal, rowIdx, cellIdx))))))\n  const[route, setRoute] = useState([STARTING_POS+1])\n  const[running, setRunning] = useState(false)\n  const[showInfo, setShowInfo] = useState(false)\n  const[showSnakeWin, setShowSnakeWin] = useState(false)\n  const[showUserWin, setShowUserWin] = useState(false)\n  const[snake, setSnake] = useState(new LinkedList(STARTING_POS))\n  const[snakeCells, setSnakeCells] = useState(new Set([STARTING_POS]))\n  const[target, setTarget] = useState(STARTING_POS+1)\n\n  const cursor = !running ? \"pointer\" : \"auto\"\n\n  // Fire snake movement when routes are set\n  useEffect(() => {\n    if(target>0 && exit===0) moveSnake()\n    if(target===-1) setRunning(false)\n  },[route])\n\n  useEffect(() => {\n    if(target>0 && exit===0) hamiltonSnakeToTarget()\n    if(target===-1) setRunning(false)\n  },[hamiltonRoute])\n\n   \n  // Handles setting the state of the highlighted cell\n  const toggleHover = (cellVal) => {\n    setCellHover(cellVal)\n  }\n\n\n  // Handles win cases of the game and toggles popup\n  const snakeWin = () => {\n    handleShowSnakeWin()\n    setExit(1)\n    setRunning(false)\n  }\n  const playerWin = () => {\n    handleShowUserWin()     \n    setExit(1)\n    setRunning(false)\n  }\n\n\n  // Function called on click, triggers path finding and snake movement\n  // If no optimal path is found by easyBFS, it will run the shortest path through itself to end game, \n  const setNextTarget = (target) => {\n    if(!snakeCells.has(target) && algorithm && !running && exit===0) {\n      setTarget(target)\n      setTargetNodeInBoard(target)\n      setRunning(true)\n      let path = []\n      if(algorithm===\"Easy\") path = easyBFS(snake, target, nodeBoard)\n      else if(algorithm===\"Medium\") path = mediumBFS(snake, target, nodeBoard, snakeCells)\n      else if(algorithm===\"Hard\") path = hardBFS(snake, target, nodeBoard, snakeCells)\n      else if(algorithm===\"Impossible\") {\n        if(hamiltonRoute.length===0) setHamiltonRoute(Array.from(hamilton()))\n        else setHamiltonRoute(Array.from(hamiltonRoute))\n      }\n      if(algorithm!==\"Impossible\"){\n        if(path.length===0) path = easyBFS(snake, target, nodeBoard, new Set())\n        setRoute(Array.from(path))\n      }\n    }\n  }\n\n  // Find and set the target in nodeBoard\n  const setTargetNodeInBoard = (cellVal) => {\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    nodeBoard[rowId][colId].isTarget = true\n  }\n\n  // Sets route for snake to move along hamilton path\n  const hamiltonSnakeToTarget = () => {\n    let path = Array.from(hamiltonRoute)\n    let pathToAppend = path.splice(0, path.indexOf(snake.head.value)+1)\n    path = path.concat(pathToAppend)\n    while(path.length>1 && path[path.length-1]!==target){\n      path.pop()\n    }\n    setRoute(Array.from(path))\n  }\n\n  // Responsible for moving the snake, and exiting if it runs into itself\n  const moveSnake = () => {\n    const nextSnakeHeadVal = route.shift()\n    if(nextSnakeHeadVal===undefined) return\n    const newHead = new LinkedListNode(nextSnakeHeadVal)\n    const newSnakeCells = new Set(snakeCells)\n\n    if(newSnakeCells.has(nextSnakeHeadVal) && nextSnakeHeadVal!==snake.tail.value) playerWin()   \n    else{\n      if(nextSnakeHeadVal===target){\n        setTarget(-1)\n      }\n      else{\n        newSnakeCells.delete(snake.tail.value)\n        snake.tail = snake.tail.next\n      }\n      const currentHead = snake.head\n      snake.head = newHead\n      currentHead.next = newHead\n      newSnakeCells.add(nextSnakeHeadVal)\n    }\n    setSnakeCells(newSnakeCells)\n    if(newSnakeCells.has(snake.head.value+1) && newSnakeCells.has(snake.head.value-1)\n      && newSnakeCells.has(snake.head.value+BOARD_SIZE) && newSnakeCells.has(snake.head.value-BOARD_SIZE)){\n        newSnakeCells.size===BOARD_SIZE*BOARD_SIZE ? snakeWin() : playerWin()\n    }\n    setTimeout(() => {\n      setRoute(Array.from(route))      \n    }, SNAKE_SPEED)\n  }\n\n\n  // Resets the state variables when game is to be reset\n  const handleReset = () => {\n    setNodeBoard( board.map((row, rowIdx) => (\n                   row.map((cellVal, cellIdx) => (\n                     new Node(cellVal, rowIdx, cellIdx))))))\n    setSnakeCells(new Set([STARTING_POS]))\n    setSnake(new LinkedList(STARTING_POS))\n    setTarget(STARTING_POS+1)\n    setRoute([STARTING_POS+1])\n    setExit(0)\n  }\n\n\n  // Functions for displaying modal popup and its contents\n  const handleCloseInfo = () => setShowInfo(false)\n  const handleShowInfo = () => setShowInfo(true)\n  const popupContent = () => {\n    return(\n      <div>\n        <span id=\"info\" onClick={handleShowInfo}>\n          <FontAwesomeIcon icon={faInfoCircle}/>\n        </span>\n        <Modal show={showInfo} onHide={handleCloseInfo}>\n          <Modal.Header closeButton>\n            <Modal.Title>Welcome to Hungry Snake</Modal.Title>\n          </Modal.Header>\n          <Modal.Body>\n            <span id=\"instruction\">Place food on the grid for the snake to try and eat</span><br/>\n            <span id=\"instruction\">Aim for as low a score as possible!</span><br/>\n            <span id=\"setting\" style={{color: \"limegreen\"}}>Easy</span>: \n              Snake uses BFS with no self detection to find a path to the food.<br/>\n            <span id=\"setting\" style={{color: \"gold\"}}>Medium</span>: \n              Snake uses BFS while regarding its body as a \"wall\" to find a path to the food when a direct path exists.<br/>\n            <span id=\"setting\" style={{color: \"tomato\"}}>Hard</span>: \n              If there is no direct BFS path to the food, Snake will follow its tail until it can reach the food or uses DFS to find a path where its tail will be clear by the time the head arrives.<br/>\n            <span id=\"setting\" style={{color: \"crimson\"}}>Impossible</span>: \n              Snake will cyclically follow a Hamiltonian Path around the grid, visiting every grid cell only once on each cycle. Snake will always be able to reach food.<br/>\n          </Modal.Body>\n          <Modal.Footer>\n            <Button variant=\"secondary\" onClick={handleCloseInfo}>\n              Close\n            </Button>\n          </Modal.Footer>\n        </Modal>\n      </div>\n    )\n  }\n\n  // Functions for showing game end popup and its contents\n  const handleShowUserWin = () => setShowUserWin(true)\n  const handleShowSnakeWin = () => setShowSnakeWin(true)\n  const handleGameEndPopupClose = () => {\n    setShowUserWin(false)\n    setShowSnakeWin(false)\n  }\n  const handleGameEndPopupCloseAndReset = () => {\n    setShowUserWin(false)\n    setShowSnakeWin(false)\n    handleReset()\n  }\n  const gameEndPopup = () => {\n    return (\n      <div>\n        <Modal \n          show={showUserWin || showSnakeWin} \n          onHide={handleGameEndPopupClose} \n          centered\n          size=\"sm\"\n        >\n          <Modal.Header style={{textAlign:\"center\", margin:\"0 auto\"}}>\n            <Modal.Title>\n              {showUserWin ? \"You win!\" : showSnakeWin ? \"Snake Wins!\" : null}\n            </Modal.Title>\n          </Modal.Header>\n          <Modal.Footer style={{textAlign:\"center\", margin:\"0 auto\"}}>\n          <Button variant=\"info\" onClick={handleGameEndPopupCloseAndReset}>\n              Play Again\n            </Button>\n            <Button variant=\"secondary\" onClick={handleGameEndPopupClose}>\n              Close\n            </Button>\n          </Modal.Footer>\n        </Modal>\n      </div>\n    )\n  }\n\n  // Returns page elemens to be rendered\n  return (\n    <div>\n      <div id=\"title\"> \n        <span>Can you beat the hungry snake?</span>\n        {popupContent()}\n      </div>\n      <div>\n        <div id=\"dropdown\">\n          <Dropdown as={ButtonGroup}>\n            <Button variant=\"light\">{algorithm ? algorithm : \"Select Difficulty\" }</Button>\n              <Dropdown.Toggle split variant={algorithm ? \"light\" : \"danger\"} id=\"dropdown-split-basic\" />\n\n              <Dropdown.Menu>\n                {algorithm  ? <Dropdown.Item onClick={() => setAlgorithm(\"\")}>Select Difficulty</Dropdown.Item> : null }\n                <Dropdown.Item onClick={() => setAlgorithm(\"Easy\")}>Easy</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Medium\")}>Medium</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Hard\")}>Hard</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Impossible\")}>Impossible</Dropdown.Item>\n              </Dropdown.Menu>\n          </Dropdown>\n        </div>\n        <div\n          id=\"seperate\"\n          style={{color: 'white'}}>\n          |\n        </div>\n        <div\n          id=\"reset\"\n          style={{cursor: cursor}}\n          onClick={() => handleReset()}>\n          Reset Game\n        </div>\n      </div>\n      <div>\n        {board.map((row, rowIdx) => (\n          <div key={rowIdx} className=\"row\">\n            {row.map((cellVal, cellIdx) => (\n              <div \n                key={cellIdx}\n                onMouseEnter={() => toggleHover(cellVal)} \n                onMouseLeave={() => toggleHover(-1)}\n                onClick = {() => setNextTarget(cellVal)}\n                className={`cell ${ cellVal===snake.head.value ? 'cell-snake-head'\n                : snakeCells.has(cellVal) ? 'cell-snake'\n                : cellVal===target ? 'cell-food'\n                : cellVal===cellHover ? 'cell-hover'\n                : route.includes(cellVal)? 'cell'\n                : ''}`}\n              >\n            </div>\n            ))}\n          </div>\n        ))}\n      </div>\n      <span>score: {snakeCells.size-2}</span>\n      {gameEndPopup()}\n    </div>\n  )\n}\n\nclass LinkedList{\n  constructor(value) {\n    const node = new LinkedListNode(value)\n    this.head = node\n    this.tail = node\n  }\n}\n\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value\n    this.next = null\n  }\n}\n\nclass Node{\n  constructor(value, row, col){\n    this.value = value\n    this.row = row\n    this.col = col\n    this.isPath = false\n    this.previousNodePath = null\n  }\n}\n\nfunction createBoard(BOARD_SIZE) {\n  let counter = 1\n  const board = []\n  for(let row=0; row<BOARD_SIZE; row++){\n    const currRow = []\n    for(let col=0; col<BOARD_SIZE; col++){\n      currRow.push(counter++)\n    }\n    board.push(currRow)\n  }\n  return board\n}\n\nexport default Display","import React, { Component } from 'react'\nimport Display from './components/Display'\nimport './App.css'\n\nclass App extends Component {\n  render(){\n    return (\n      <div className=\"App\">\n        <Display/>\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}