{"version":3,"sources":["algorithms/easyBFS.js","algorithms/mediumBFS.js","algorithms/hardBFS.js","algorithms/hamilton.js","components/Display.js","App.js","serviceWorker.js","index.js"],"names":["BOARD_SIZE","easyBFS","snake","target","nodeBoard","cellVal","headCoordinate","head","value","Math","floor","rowId","colId","visited","Array","pow","fill","queue","path","push","temp","tail","revSnake","unshift","next","diff","i","length","preventReverse","currentNode","shift","tempNode","previousNodePath","isPath","node","potentialNeighbor","neighbors","row","col","findNeighbors","forEach","neighbor","mediumBFS","snakeCells","has","hardBFS","NUMBER_VERTICES","hamiltonSolverDFS","graph","pos","included","v","isSafe","add","delete","hamilton","hamiltonGraph","nodeAdjacency","valueRow","valueCol","setHamiltonAdjacencyList","Set","map","val","STARTING_POS","LinkedListNode","this","LinkedList","Node","Display","useState","counter","board","currRow","createBoard","rowIdx","cellIdx","setNodeBoard","setSnakeCells","setSnake","setTarget","cellHover","setCellHover","route","setRoute","hamiltonRoute","setHamiltonRoute","exit","setExit","running","setRunning","algorithm","setAlgorithm","toggleHover","useEffect","moveSnake","hamiltonSnakeToTarget","playerWin","console","log","setTargetNodeInBoard","isTarget","from","pathToAppend","splice","indexOf","concat","pop","nextSnakeHeadVal","undefined","newHead","newSnakeCells","currentHead","size","setTimeout","cursor","id","Dropdown","as","ButtonGroup","Button","variant","Toggle","split","Menu","Item","onClick","style","color","className","onMouseEnter","onMouseLeave","setNextTarget","includes","App","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6391bf93.chunk.js","sourcesContent":["const BOARD_SIZE = 12\n\nfunction easyBFS (snake, target, nodeBoard){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = []\n    queue.push(nodeBoard[rowId][colId])\n\n    preventReverse(snake, visited)\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(currentNode, nodeBoard)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value]){\n                visited[neighbor.value] = true\n                nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                queue.push(neighbor)\n            }\n        })\n    }\n    return path\n}\n\nfunction preventReverse(snake, visited){\n    let temp = snake.tail\n    let revSnake = []\n\n    while(temp){\n        revSnake.unshift(temp.value)\n        temp = temp.next\n    }\n    let diff = revSnake[1] - revSnake[0]\n    visited[revSnake[0]] = true\n    visited[revSnake[1]] = true\n    for(let i=1; i<revSnake.length-1; i++){\n        if(revSnake[i+1] - revSnake[i] === diff) visited[revSnake[i+1]]=true\n        else break\n    }\n}\n\nfunction findNeighbors(node, nodeBoard){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\n\nexport default easyBFS","const BOARD_SIZE = 12\n\nfunction mediumBFS (snake, target, nodeBoard, snakeCells){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = []\n    queue.push(nodeBoard[rowId][colId])\n\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(currentNode, nodeBoard)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value] && !snakeCells.has(neighbor.value)){\n                visited[neighbor.value] = true\n                nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                queue.push(neighbor)\n            }\n        })\n    }\n    return path\n}\n\nfunction findNeighbors(node, nodeBoard){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\nexport default mediumBFS","const BOARD_SIZE = 12\n\nfunction hardBFS (snake, target, nodeBoard, snakeCells){\n    let headCoordinate = findHeadRC(snake.head.value)\n    let rowId = headCoordinate[0], colId = headCoordinate[1]\n\n    let visited = new Array(Math.pow(BOARD_SIZE, 2)).fill(false)\n    visited[snake.head.value] = true\n\n    let queue = [], path = []\n    queue.push(nodeBoard[rowId][colId])\n\n    preventReverse(snake, visited)\n\n    while(queue.length){\n        let currentNode = queue.shift()\n        visited[currentNode.value] = true\n        if(currentNode.value===target) {\n            let tempNode = currentNode\n            while(tempNode.value!==snake.head.value){\n                tempNode.previousNodePath.isPath = true\n                path.unshift(tempNode.value)\n                tempNode = tempNode.previousNodePath\n             }\n            return path\n        }\n        let currentNeighbors = findNeighbors(snake, currentNode, nodeBoard, snakeCells)\n        currentNeighbors.forEach(neighbor => {\n            if(!visited[neighbor.value] && !snakeCells.has(neighbor.value)){\n                visited[neighbor.value] = true\n                nodeBoard[neighbor.row][neighbor.col].previousNodePath = currentNode\n                queue.push(neighbor)\n            }\n        })\n    }\n    return path\n}\n\nfunction preventReverse(snake, visited){\n    let temp = snake.tail\n    let revSnake = []\n\n    while(temp){\n        revSnake.unshift(temp.value)\n        temp = temp.next\n    }\n    let diff = revSnake[0] - revSnake[1]\n    visited[revSnake[0]] = true\n    visited[revSnake[1]] = true\n    for(let i=1; i<revSnake.length-1; i++){\n        if(revSnake[i] - revSnake[i+1] === diff) visited[i]=true\n        else break\n    }\n}\n\nfunction findNeighbors(snake, node, nodeBoard, snakeCells){\n    let neighbors = []\n    let potentialNeighbor\n    if(nodeBoard[node.row-1] && nodeBoard[node.row-1][node.col]){\n        potentialNeighbor = nodeBoard[node.row-1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row+1] && nodeBoard[node.row+1][node.col]){\n        potentialNeighbor = nodeBoard[node.row+1][node.col]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col-1] && nodeBoard[node.row][node.col-1]){\n        potentialNeighbor = nodeBoard[node.row][node.col-1]\n        neighbors.push(potentialNeighbor)\n    }\n    if(nodeBoard[node.row][node.col+1] && nodeBoard[node.row][node.col+1]){\n        potentialNeighbor = nodeBoard[node.row][node.col+1]\n        neighbors.push(potentialNeighbor)\n    }\n    return neighbors\n}\n\n\nfunction findHeadRC(cellVal){\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    return [rowId, colId]\n}\n\nexport default hardBFS","/*\n * Finds the Hamilton Path using DFS and backtracking, which is usually a O(n!)\n * operation. It would not work for grid larger than 6x6, when\n * I set the adjacency list so each node points to every neighbor node. \n * \n * I then set out to implement it with Dynamic Programming and Bitmasking, \n *  as can be seen in the function HAMILTONSOLVERDP. This algorithm is much faster,\n *  but I am not very competant with Bitwise operations, so I could only use \n *  this algorithm to find if a path existed, but could not get the \n *  function to return the path.\n * \n *  So I returned to the DFS and backtracking solution, but made some \n *  changes to my adjacency list. Since the Hamilton Path will follow \n *  the same pattern for even side-length grids, I changed each node to only \n *  be adjacent to the nodes which follow this Hamilton pattern,\n *  although there are other valid Hamilton patterns / paths. This forced DFS to explore\n *  far fewer permutations, and therefore run significantly faster.\n * \n * Algorithms sourced from:\n * DFS/Backtracking: https://www.geeksforgeeks.org/hamiltonian-cycle-backtracking-6/\n * DP: https://www.geeksforgeeks.org/hamiltonian-path-using-dynamic-programming/\n*/\n\nconst BOARD_SIZE = 12\nconst NUMBER_VERTICES = Math.pow(BOARD_SIZE, 2)\n\nfunction hamilton (){\n    let hamiltonGraph = setHamiltonAdjacencyList()\n    let path = new Array(BOARD_SIZE).fill(-1)\n    path[0] = 0\n    let included = new Set()\n    included.add(0)\n    if(hamiltonSolverDFS(hamiltonGraph, path, 1, included)===false) return []\n    path = path.map(val => val+1)\n    return path\n}\n\nfunction hamiltonSolverDFS(graph, path, pos, included){\n    if(pos===NUMBER_VERTICES){\n        if(graph[path[pos-1]][path[0]]===1) return true\n        else return false\n    }\n    for(let v=1; v<NUMBER_VERTICES; v++){\n        if(isSafe(v, graph, path, pos, included)){\n            path[pos] = v\n            included.add(v)\n            if(hamiltonSolverDFS(graph, path, pos+1, included)===true) return true\n            path[pos] = -1\n            included.delete(v)\n        }\n    }\n    return false\n}\n\nfunction isSafe(v, graph, path, pos, included){\n    if(graph[path[pos-1]][v]===0) return false\n    if(included.has(v)) return false\n    return true\n}\n\nfunction setHamiltonAdjacencyList(){\n    let hamiltonGraph = []\n    for(let i=0; i<NUMBER_VERTICES; i++){\n        let nodeAdjacency = new Array(NUMBER_VERTICES).fill(0)\n        let valueRow = Math.floor(i/BOARD_SIZE)\n        let valueCol = i%BOARD_SIZE\n\n        if(valueRow===0){\n            if(valueCol===0){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1\n            }\n        }\n        else if(valueRow===BOARD_SIZE-1){\n            if(valueCol===0){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1\n            }\n        }\n        else{\n            if(valueCol===0){\n                nodeAdjacency[i+BOARD_SIZE] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1\n            }\n            else if(valueCol===1){\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n            }\n            else if(valueCol===BOARD_SIZE-1){\n                nodeAdjacency[i-1] = 1\n                nodeAdjacency[i+BOARD_SIZE] = 1\n                nodeAdjacency[i-BOARD_SIZE] = 1            \n            }\n            else{\n                nodeAdjacency[i+1] = 1\n                nodeAdjacency[i-1] = 1          \n            }\n        }\n        hamiltonGraph.push(nodeAdjacency)\n    }\n    return hamiltonGraph\n}\n\n// function hamiltonSolverDP(graph, path){\n//     let N = graph.length\n\n//     let dp = new Array(N).fill(new Array(1 << N))\n//     for(let i=0; i<N; i++){\n//         dp[i][1<<i] = true\n//     }\n\n//     for(let i=0; i < (1<<N); i++){\n//         for(let j=0; j<N; j++){\n//             if((i & (1<<j)) !== 0){\n//                 for(let k=0; k<N; k++){\n//                     if((i & (1<<k)) !== 0 && \n//                         graph[k][j]===1 && j!==k &&\n//                         dp[k][i ^ (1<<j)]){\n//                             console.log(graph[k][j])\n//                             dp[j][i] = true\n//                             break\n//                         }\n//                 }\n//             }\n//         }\n//     }\n//     for(let i=0; i<N; i++){\n//         if(dp[i][(1<<N)-1]) return true\n//     }\n//     return false\n// }\n\n    \nexport default hamilton","/*\n  Resources: \n  https://gsurma.medium.com/slitherin-solving-the-classic-game-of-snake-with-ai-part-1-domain-specific-solvers-d1f5a5ccd635\n\n  EASY: BFS with basic self detection\n    - Prevents snake from going backward on itself\n    - If trapped (no currnent path to target) snake takes shortest path to end game\n\n  MEDIUM: BFS with improved self detection \n    - Easy + \n    - Snake finds shortest path around its current self\n    - Snake will not run into itself unless trapped (no path) by its body\n\n  Hard: Continual BFS with optimized self detection \n    - Easy + Medium + \n    - If snake traps itself, find longest path to target and move 1\n      then run medium BFS again, until it is no longer trapped or cannot move\n\n  Impossible: Hamiltonian Cycle (Snake visits every node exactly once)\n*/\nimport React, { useState, useEffect } from 'react'\nimport Dropdown from 'react-bootstrap/Dropdown'\nimport Button from 'react-bootstrap/Button'\nimport ButtonGroup from 'react-bootstrap/ButtonGroup'\n\nimport easyBFS from '../algorithms/easyBFS'\nimport mediumBFS from '../algorithms/mediumBFS'\nimport hardBFS from '../algorithms/hardBFS'\nimport hamilton from '../algorithms/hamilton'\n\nimport './css/display.css'\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nconst BOARD_SIZE = 12\nconst SNAKE_SPEED = 75\nconst STARTING_POS = 75\n\nconst Display = () => {\n  const[board] = useState(createBoard(BOARD_SIZE))\n  const[nodeBoard, setNodeBoard] = useState(\n    board.map((row, rowIdx) => (\n      row.map((cellVal, cellIdx) => (\n        new Node(cellVal, rowIdx, cellIdx))))))\n  const[snakeCells, setSnakeCells] = useState(new Set([STARTING_POS]))\n  const[snake, setSnake] = useState(new LinkedList(STARTING_POS))\n  const[target, setTarget] = useState(STARTING_POS+1)\n  const[cellHover, setCellHover] = useState(-1)\n  const[route, setRoute] = useState([STARTING_POS+1])\n  const[hamiltonRoute, setHamiltonRoute] = useState([])\n  const[exit, setExit] = useState(0)\n  const[running, setRunning] = useState(false)\n  const[algorithm, setAlgorithm] = useState(\"\")\n\n  // Handles setting the state of the highlighted cell\n  const toggleHover = (cellVal) => {\n    setCellHover(cellVal)\n  }\n\n  useEffect(() => {\n    if(target>0 && exit===0) moveSnake()\n    if(target===-1) setRunning(false)\n  },[route])\n\n  useEffect(() => {\n    if(target>0 && exit===0) hamiltonSnakeToTarget()\n    if(target===-1) setRunning(false)\n  },[hamiltonRoute])\n\n  // Handles win cases of the game\n  const snakeWin = () => {\n    console.log(\"Snake Wins!\")\n    setExit(1)\n    setRunning(false)\n  }\n\n  const playerWin = () => {\n    console.log(\"You Win!\")      \n    setExit(1)\n    setRunning(false)\n  }\n\n  // Function called on click, triggers path finding and snake movement\n  // If no optimal path is found by easyBFS, it will run the shortest path through itself to end game, \n  const setNextTarget = (target) => {\n    if(!snakeCells.has(target) && algorithm && !running && exit===0) {\n      setTarget(target)\n      setTargetNodeInBoard(target)\n      setRunning(true)\n      let path = []\n      if(algorithm===\"Easy\") path = easyBFS(snake, target, nodeBoard)\n      else if(algorithm===\"Medium\") path = mediumBFS(snake, target, nodeBoard, snakeCells)\n      else if(algorithm===\"Hard\") path = hardBFS(snake, target, nodeBoard, snakeCells)\n      else if(algorithm===\"Impossible\") {\n        if(hamiltonRoute.length===0) setHamiltonRoute(Array.from(hamilton()))\n        else setHamiltonRoute(Array.from(hamiltonRoute))\n      }\n      if(algorithm!==\"Impossible\"){\n        if(path.length===0) path = easyBFS(snake, target, nodeBoard, new Set())\n        setRoute(Array.from(path))\n      }\n    }\n  }\n\n  // Find and set the target in nodeBoard\n  const setTargetNodeInBoard = (cellVal) => {\n    let rowId = Math.floor((cellVal-1)/BOARD_SIZE)\n    let colId = cellVal%BOARD_SIZE===0 ? BOARD_SIZE-1 : cellVal%BOARD_SIZE-1\n    nodeBoard[rowId][colId].isTarget = true\n  }\n\n  const hamiltonSnakeToTarget = () => {\n    let path = Array.from(hamiltonRoute)\n    let pathToAppend = path.splice(0, path.indexOf(snake.head.value)+1)\n    path = path.concat(pathToAppend)\n    while(path.length>1 && path[path.length-1]!==target){\n      path.pop()\n    }\n    setRoute(Array.from(path))\n  }\n\n  // Responsible for moving the snake, and exiting if it runs into itself\n  const moveSnake = () => {\n    const nextSnakeHeadVal = route.shift()\n    if(nextSnakeHeadVal===undefined) return\n    const newHead = new LinkedListNode(nextSnakeHeadVal)\n    const newSnakeCells = new Set(snakeCells)\n\n    if(nextSnakeHeadVal===target){\n      setTarget(-1)\n    }\n    else{\n      newSnakeCells.delete(snake.tail.value)\n      snake.tail = snake.tail.next\n    }\n    if(newSnakeCells.has(nextSnakeHeadVal)) playerWin()   \n    else{\n      const currentHead = snake.head\n      snake.head = newHead\n      currentHead.next = newHead\n      newSnakeCells.add(nextSnakeHeadVal)\n    }\n    setSnakeCells(newSnakeCells)\n    if(newSnakeCells.has(snake.head.value+1) && newSnakeCells.has(snake.head.value-1)\n      && newSnakeCells.has(snake.head.value+BOARD_SIZE) && newSnakeCells.has(snake.head.value-BOARD_SIZE)){\n        newSnakeCells.size===BOARD_SIZE*BOARD_SIZE ? snakeWin() : playerWin()\n    }\n    setTimeout(() => {\n      setRoute(Array.from(route))      \n    }, SNAKE_SPEED)\n  }\n\n  const handleReset = () => {\n    setNodeBoard( board.map((row, rowIdx) => (\n                   row.map((cellVal, cellIdx) => (\n                     new Node(cellVal, rowIdx, cellIdx))))))\n    setSnakeCells(new Set([STARTING_POS]))\n    setSnake(new LinkedList(STARTING_POS))\n    setTarget(STARTING_POS+1)\n    setRoute([STARTING_POS+1])\n    setExit(0)\n  }\n\n  const cursor = !running ? \"pointer\" : \"auto\"\n\n  return (\n    <div>\n      <div>\n        <div id=\"dropdown\">\n          <Dropdown as={ButtonGroup}>\n            <Button variant=\"light\">{algorithm ? algorithm : \"Select Difficulty\" }</Button>\n              <Dropdown.Toggle split variant={algorithm ? \"light\" : \"danger\"} id=\"dropdown-split-basic\" />\n\n              <Dropdown.Menu>\n                {algorithm  ? <Dropdown.Item onClick={() => setAlgorithm(\"\")}>Select Difficulty</Dropdown.Item> : null }\n                <Dropdown.Item onClick={() => setAlgorithm(\"Easy\")}>Easy</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Medium\")}>Medium</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Hard\")}>Hard</Dropdown.Item>\n                <Dropdown.Item onClick={() => setAlgorithm(\"Impossible\")}>Impossible</Dropdown.Item>\n              </Dropdown.Menu>\n          </Dropdown>\n        </div>\n        <div\n          id=\"seperate\"\n          style={{color: 'white'}}>\n          |\n        </div>\n        <div\n          id=\"generate\"\n          style={{cursor: cursor}}\n          onClick={() => handleReset()}>\n          Reset Game\n        </div>\n      </div>\n      <div>\n        {board.map((row, rowIdx) => (\n          <div key={rowIdx} className=\"row\">\n            {row.map((cellVal, cellIdx) => (\n              <div \n                key={cellIdx}\n                onMouseEnter={() => toggleHover(cellVal)} \n                onMouseLeave={() => toggleHover(-1)}\n                onClick = {() => setNextTarget(cellVal)}\n                className={`cell ${ cellVal===snake.head.value ? 'cell-snake-head'\n                : snakeCells.has(cellVal) ? 'cell-snake'\n                : cellVal===target ? 'cell-food'\n                : cellVal===cellHover ? 'cell-hover'\n                : route.includes(cellVal)? 'cell-path'\n                : ''}`}\n              >\n            </div>\n            ))}\n          </div>\n        ))}\n      </div>\n      <span>score: {snakeCells.size-2}</span>\n    </div>\n  )\n}; \n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value\n    this.next = null\n  }\n}\n\nclass LinkedList{\n  constructor(value) {\n    const node = new LinkedListNode(value)\n    this.head = node\n    this.tail = node\n  }\n}\n\nclass Node{\n  constructor(value, row, col){\n    this.value = value\n    this.row = row\n    this.col = col\n    this.isPath = false\n    this.previousNodePath = null\n  }\n}\n\nfunction createBoard(BOARD_SIZE) {\n  let counter = 1\n  const board = []\n  for(let row=0; row<BOARD_SIZE; row++){\n    const currRow = []\n    for(let col=0; col<BOARD_SIZE; col++){\n      currRow.push(counter++)\n    }\n    board.push(currRow)\n  }\n  return board\n}\n\nexport default Display","import React, { Component } from 'react'\nimport Display from './components/Display'\nimport './App.css'\n\nclass App extends Component {\n  render(){\n    return (\n      <div className=\"App\">\n        <div>\n          <h3>Can you beat the hungry snake?</h3>\n        </div>\n        <Display/>\n      </div>\n    );\n  }\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}